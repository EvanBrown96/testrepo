{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
\cocoascreenfonts1{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab1120
\pard\pardeftab1120\pardirnatural\partightenfactor0

\f0\fs22 \cf0 data Maybe a  = Just a \
              | Nothing\
\
\
main :: IO String\
main = do\
    val <- getArgs\
    putStrLn "Hello, World"\
    getLine\
\
unit type = ()\
    - need to return something, but there's nothing to give back\
\
getArgs function in System.Environment\
\
punning - a type has the same name as a constructor\
    data () = ()\
    data Vector a = Vector a a a \
	- usually do punning with types with only one constructor\
\
type declaration - actually a type SYNONYM\
    type String = [Char]\
    type Pos = (Int, Int)\
    type Pair a = (a, a)\
	- cannot be recursive, but can be nested\
\
data declaration - creates a new type\
    data Bool = False | True\
	- False and True are constructors of type Bool\
    data Answer = Yes | No | Unknown\
    data Shape = Circle Float | Rect Float Float\
	- constructors take parameters of some floats\
    	square :: Float -> Shape\
	square n = Rect n n\
	area :: Shape -> Float\
	area (Circle r) = pi * r^2\
	area (Rect x y) = x * y\
    - type class constraints are useless in data declarations\
    - constructors are functions that return values of their type\
	Circle :: Float -> Shape\
	Rect :: Float -> Float -> Shape\
    - data types CAN be recursive\
\
data Nat = Zero | Succ Nat\
\
intToNat :: Int -> Nat\
intToNat 0 = Zero\
intToNat n = Succ (intToNat (n-1))\
\
natToInt :: Nat -> Int\
natToInt Zero = 0\
natToInt (Succ n) = 1 + natToInt n\
\
addNats :: Nat -> Nat -> Nat\
addNats Zero n = n\
addNats n Zero = n\
addNats m (Succ n) = addNats (Succ m) n\
\
or:\
\
addNats (Succ m) n = Succ (addNats x y)\
\
\
data Expr = Val Int\
	  | Add Expr Expr\
	  | Mul Expr Expr\
\
	(basically a BNF)\
\
size Expr -> Int\
size (Val _) = 1\
size (Add a b) = size a + size b\
size (Mul a b) = size a + size b\
\
add something\
}